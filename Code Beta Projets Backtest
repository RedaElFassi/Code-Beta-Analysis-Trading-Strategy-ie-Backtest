# =========================
# Imports
# =========================
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import matplotlib.cm as cm
import matplotlib.dates as mdates
from matplotlib.colors import Normalize
import statsmodels.api as sm

# =========================
# Paramètres généraux (modifie ici)
# =========================
COUNTRY_HIGH  = "Italy"      # pays avec le plus haut yield long (ex: Italy)
COUNTRY_LOW   = "Germany"    # benchmark du spread (ex: Germany)
BENCHMARK_CURVE_COUNTRY = "Germany"  # pays utilisé pour la courbe (curve)

MATU_LONG  = "10Y"           # maturité longue (ex: 10Y)
MATU_SHORT = "5Y"            # maturité courte (ex: 5Y)
MATU_SPREAD = "10Y"          # maturité du spread pour la régression (ex: 10Y)

# Fenêtres pour l’analyse (rolling regressions)
ROLLING_WINDOW_DAYS = 63     # taille de la fenêtre glissante (≈ 3 mois)
MIN_OBS_IN_WINDOW   = 63     # on exige une fenêtre pleine

# Fenêtres pour le backtest (INTERPRÉTÉES COMME NOMBRE D'OBSERVATIONS)
TRAIN_WINDOW_DAYS = 126      # 6 mois ≈ 126 obs
OBS_WINDOW_DAYS   = 21       # 1 mois ≈ 21 obs entre fin training et jour d’entrée
HOLDING_DAYS      = 21       # 1 mois max de détention ≈ 21 obs

# Seuils & notionnel
RESID_THRESHOLD     = 2.0    # seuil |epsilon| pour déclencher un trade
R2_ENTRY_THRESHOLD  = 0.30   # filtre R² minimum
TP_MULT             = 0.5    # TP = 0.5 * threshold (en pts de BOX)
SL_MULT             = 0.5    # SL = 0.5 * threshold
DV01_K              = 10.0   # 10 => 10k€ de DV01 notionnel

# Driver utilisé pour le backtest (sur niveaux)
DRIVER_FOR_SIGNAL   = "SPREAD"  # "SPREAD" ou "CURVE"


# =========================
# Helper pour les noms de colonnes
# =========================
def col(country: str, matu: str) -> str:
    """Construit un nom de colonne standard 'Country Maturity' (ex: 'Italy 10Y')."""
    return f"{country} {matu}"


# =========================
# Construction des séries: BOX, SPREAD, CURVE
# =========================
def build_series(data: pd.DataFrame,
                 country_high: str, country_low: str,
                 matu_long: str, matu_short: str,
                 matu_spread: str,
                 curve_country: str) -> pd.DataFrame:
    """
    Construit 3 séries structurantes (index daté trié attendu) :
      BOX    = (High_long - Low_long) - (High_short - Low_short)
      SPREAD = High_matu_spread - Low_matu_spread
      CURVE  = (curve_country long - curve_country short)
    """
    s_high_long  = data[col(country_high,  matu_long )]
    s_low_long   = data[col(country_low,   matu_long )]
    s_high_short = data[col(country_high,  matu_short)]
    s_low_short  = data[col(country_low,   matu_short)]

    box    = (s_high_long - s_low_long) - (s_high_short - s_low_short)
    spread = data[col(country_high, matu_spread)] - data[col(country_low, matu_spread)]
    curve  = data[col(curve_country, matu_long)] - data[col(curve_country, matu_short)]

    out = pd.DataFrame({"BOX": box, "SPREAD": spread, "CURVE": curve}).dropna()
    return out


# =========================
# Rolling regression (générique, sur NIVEAUX OU Δ)
# =========================
def rolling_regression(y: pd.Series, x: pd.Series, window: int, min_obs: int = 63) -> pd.DataFrame:
    """
    OLS glissante (y ~ const + x) sur fenêtres de taille `window`.
    Stocke Alpha (constante), Beta, R², T-stat, et le résiduel au dernier point de chaque fenêtre.
    """
    y = y.dropna(); x = x.dropna()
    df = pd.concat([y.rename("y"), x.rename("x")], axis=1).dropna()
    res = []
    if len(df) < window:
        return pd.DataFrame(columns=["Alpha","Beta","R2","T_stat","Residual"])

    for end in range(window, len(df)+1):
        w = df.iloc[end-window:end]
        if w.shape[0] < min_obs:
            continue
        X = sm.add_constant(w["x"].values)
        model = sm.OLS(w["y"].values, X).fit()

        last_y = w["y"].iloc[-1]
        last_x = w["x"].iloc[-1]
        y_hat_last = model.params[0] + model.params[1]*last_x

        res.append({
            "Date": w.index[-1],
            "Alpha": float(model.params[0]),
            "Beta":  float(model.params[1]),
            "R2":    float(model.rsquared),
            "T_stat": float(model.tvalues[1]),
            "Residual": float(last_y - y_hat_last)  # résidu au point de fin de fenêtre
        })
    return pd.DataFrame(res).set_index("Date")


# =========================
# Plots (analyse) — suptitle global, sous-titres concis
# =========================
def plot_regression_results(df: pd.DataFrame, title_prefix: str):
    """Affiche 4 sous-graphiques (R², Beta, T-stat, Residual) avec un SEUL titre global."""
    if df.empty:
        print(f"[plot_regression_results] Aucun résultat pour: {title_prefix}")
        return
    fig, axes = plt.subplots(2, 2, figsize=(24, 12))
    fig.suptitle(title_prefix, fontsize=18, fontweight="bold", y=0.98)

    axes[0,0].plot(df.index, df["R2"], label="R²");        axes[0,0].set_title("R²"); axes[0,0].legend(); axes[0,0].grid(True)
    axes[0,1].plot(df.index, df["Beta"], label="Beta");     axes[0,1].set_title("Beta"); axes[0,1].legend(); axes[0,1].grid(True)
    axes[1,0].plot(df.index, df["T_stat"], label="T-stat"); axes[1,0].set_title("T-stat"); axes[1,0].legend(); axes[1,0].grid(True)
    axes[1,1].plot(df.index, df["Residual"], label="Residual (window end)"); axes[1,1].set_title("Residual (window end)"); axes[1,1].legend(); axes[1,1].grid(True)

    for ax in axes.flat:
        ax.xaxis.set_major_locator(mdates.YearLocator()); ax.xaxis.set_major_formatter(mdates.DateFormatter('%Y'))
        plt.setp(ax.get_xticklabels(), rotation=45, ha='right')
    plt.tight_layout(rect=[0, 0, 1, 0.95]); plt.show()


def plot_scatter_beta(df_results: pd.DataFrame, series_level: pd.Series, x_label: str, title: str):
    """Scatter Beta (y) vs Niveau (x = Spread/Curve ou ΔSpread/ΔCurve), coloré par année."""
    common_idx = df_results.index.intersection(series_level.index)
    if len(common_idx) == 0:
        print(f"[plot_scatter_beta] Index commun vide pour: {title}")
        return
    x = series_level.reindex(common_idx); beta = df_results.loc[common_idx, "Beta"]
    years = common_idx.year; cmap = cm.get_cmap("coolwarm"); norm = Normalize(vmin=years.min(), vmax=years.max())
    plt.figure(figsize=(10,6))
    plt.scatter(x, beta, c=[cmap(norm(y)) for y in years])
    cbar = plt.colorbar(cm.ScalarMappable(norm=norm, cmap=cmap)); cbar.set_label("Year")
    plt.xlabel(x_label); plt.ylabel("Beta"); plt.title(title); plt.grid(True); plt.show()


# =========================
# 1) Analyse NIVEAUX (paramétrable, plots optionnels)
# =========================
def run_analysis_levels(data: pd.DataFrame, window: int = ROLLING_WINDOW_DAYS, do_plots: bool = True):
    """
    Analyse sur niveaux: rolling BOX~SPREAD et BOX~CURVE + (plots si do_plots) + DataFrames.
    RETOUR: (series, rr_spread_lvl, rr_curve_lvl)
    """
    series = build_series(data, COUNTRY_HIGH, COUNTRY_LOW, MATU_LONG, MATU_SHORT, MATU_SPREAD, BENCHMARK_CURVE_COUNTRY)
    rr_spread = rolling_regression(series["BOX"], series["SPREAD"], window, min_obs=window)
    rr_curve  = rolling_regression(series["BOX"], series["CURVE"],  window, min_obs=window)

    if do_plots:
        plot_regression_results(rr_spread, f"BOX vs SPREAD (Levels) — {COUNTRY_HIGH}-{COUNTRY_LOW} | {MATU_SHORT}s{MATU_LONG}")
        plot_regression_results(rr_curve,  f"BOX vs CURVE  (Levels) — {BENCHMARK_CURVE_COUNTRY} {MATU_SHORT}s{MATU_LONG}")
        plot_scatter_beta(rr_spread, series["SPREAD"], "Spread Level", "Beta vs Spread (Levels)")
        plot_scatter_beta(rr_curve,  series["CURVE"],  "Curve Level",  "Beta vs Curve  (Levels)")

    return series, rr_spread, rr_curve


# =========================
# 2) Analyse DAILY CHANGES (Δ) — indépendante (paramétrable)
# =========================
def run_analysis_daily_changes(data: pd.DataFrame, window: int = ROLLING_WINDOW_DAYS, do_plots: bool = True):
    """
    Analyse sur variations quotidiennes:
      ΔBOX = BOX.diff(), ΔSPREAD = SPREAD.diff(), ΔCURVE = CURVE.diff()
    Rolling regressions: ΔBOX~ΔSPREAD et ΔBOX~ΔCURVE + (plots si do_plots).
    RETOUR: (changes_df, rr_spread_chg, rr_curve_chg)
    """
    series = build_series(data, COUNTRY_HIGH, COUNTRY_LOW, MATU_LONG, MATU_SHORT, MATU_SPREAD, BENCHMARK_CURVE_COUNTRY)
    chg = series.diff().dropna().rename(columns={"BOX":"dBOX","SPREAD":"dSPREAD","CURVE":"dCURVE"})

    rr_spread_chg = rolling_regression(chg["dBOX"], chg["dSPREAD"], window, min_obs=window)
    rr_curve_chg  = rolling_regression(chg["dBOX"], chg["dCURVE"],  window, min_obs=window)

    if do_plots:
        plot_regression_results(rr_spread_chg, f"ΔBOX vs ΔSPREAD (Daily Changes) — {COUNTRY_HIGH}-{COUNTRY_LOW} | {MATU_SHORT}s{MATU_LONG}")
        plot_regression_results(rr_curve_chg,  f"ΔBOX vs ΔCURVE  (Daily Changes) — {BENCHMARK_CURVE_COUNTRY} {MATU_SHORT}s{MATU_LONG}")
        plot_scatter_beta(rr_spread_chg, chg["dSPREAD"], "Daily ΔSpread", "Beta vs ΔSpread (Daily Changes)")
        plot_scatter_beta(rr_curve_chg,  chg["dCURVE"],  "Daily ΔCurve",  "Beta vs ΔCurve  (Daily Changes)")

    return chg, rr_spread_chg, rr_curve_chg


# =========================
# BACKTEST — utilitaire TP/SL/TIME
# =========================
def _first_cross(delta_series: pd.Series, tp: float, sl: float, side: int):
    """
    Repère la première date où ΔBOX touche TP/SL selon le sens du trade.
    LONG (side=+1): TP si Δ<=-tp ; SL si Δ>=+sl
    SHORT (side=-1): TP si Δ>=+tp ; SL si Δ<=-sl
    """
    for dt, d in delta_series.items():
        if side == +1:
            if d <= -tp: return dt, "TP"
            if d >=  sl: return dt, "SL"
        else:
            if d >=  tp: return dt, "TP"
            if d <= -sl: return dt, "SL"
    return delta_series.index[-1], "TIME"


# =========================
# 3) BACKTEST À PARTIR DE LA ROLLING REGRESSION (réutilise Alpha/Beta/R² pré-calculés)
# =========================
def backtest_from_rr(series: pd.DataFrame,
                      rr_results: pd.DataFrame,
                      driver: str = "SPREAD",
                      obs_window_days: int = OBS_WINDOW_DAYS,
                      holding_days: int = HOLDING_DAYS,
                      resid_threshold: float = RESID_THRESHOLD,
                      r2_entry_threshold: float = R2_ENTRY_THRESHOLD,
                      tp_mult: float = TP_MULT,
                      sl_mult: float = SL_MULT,
                      dv01_k: float = DV01_K):
    """
    Stratégie basée sur la **rolling regression pré-calculée** (fenêtre de TRAIN obs).
    Pour chaque fin de fenêtre d'entraînement t0 (index de rr_results):
      - Entrée candidate à t = t0 + OBS_WINDOW_DAYS (en nombre d'observations),
        en utilisant Alpha(t0), Beta(t0) et R2(t0).
      - ŷ_t = Alpha(t0) + Beta(t0) * X_t  avec X_t = series[driver] au jour t
      - ε_t  = BOX_t - ŷ_t
      - Entrée si |ε_t| >= resid_threshold et R²(t0) >= r2_entry_threshold
      - Sortie via TP/SL ou TIME sur les HOLDING_DAYS obs suivantes.
      - PnL = -side * (BOX_exit - BOX_entry) * dv01_k
    RETOUR:
      trades_df, pnl_tracker
    """
    assert "Alpha" in rr_results.columns and "Beta" in rr_results.columns and "R2" in rr_results.columns, \
        "rr_results doit contenir les colonnes Alpha, Beta, R2 (utilise rolling_regression modifié)."

    # Séries source
    y_all = series["BOX"]
    x_all = series[driver]
    idx = y_all.index

    # On itère sur chaque fin de fenêtre d'entraînement (t0)
    trades = []
    for t0 in rr_results.index:
        # position de t0 dans l'index des séries
        pos0 = idx.get_indexer([t0])[0]
        if pos0 == -1:
            continue  # t0 pas trouvé (ne devrait pas arriver si les index sont alignés)

        # Date d'entrée = après la fenêtre d'observation (obs_window_days obs plus tard)
        entry_pos = pos0 + obs_window_days
        if entry_pos >= len(idx):
            continue
        entry_date = idx[entry_pos]

        # Valeurs à l'entrée
        y_t = y_all.iloc[entry_pos]
        x_t = x_all.iloc[entry_pos]
        if pd.isna(y_t) or pd.isna(x_t):
            continue

        # Paramètres gelés au t0 (fin de training)
        alpha_t0 = rr_results.loc[t0, "Alpha"]
        beta_t0  = rr_results.loc[t0, "Beta"]
        r2_t0    = rr_results.loc[t0, "R2"]

        # Prédiction & résidu à la date d'entrée
        y_hat_t = alpha_t0 + beta_t0 * x_t
        resid_t = y_t - y_hat_t

        # Filtre d'entrée
        if (abs(resid_t) < resid_threshold) or (r2_t0 < r2_entry_threshold):
            continue

        # Direction
        side = +1 if resid_t > 0 else -1
        entry_box = float(y_t)

        # Trajectoire sur les HOLDING_DAYS obs suivantes
        exit_pos = min(entry_pos + holding_days, len(idx) - 1)
        path = y_all.iloc[entry_pos+1: exit_pos+1]  # (entry; exit]
        if len(path) == 0:
            exit_date = entry_date
            exit_box  = entry_box
            reason    = "TIME"
        else:
            delta = path - entry_box
            tp = tp_mult * resid_threshold
            sl = sl_mult * resid_threshold
            exit_date, reason = _first_cross(delta, tp, sl, side)
            exit_box = float(y_all.loc[exit_date])

        pnl = -side * (exit_box - entry_box) * dv01_k

        trades.append({
            "Entry": entry_date,
            "Exit": exit_date,
            "Side": "LONG_BOX" if side==+1 else "SHORT_BOX",
            "EntryBox": entry_box,
            "Predicted": float(y_hat_t),
            "Residual": float(resid_t),
            "Beta": float(beta_t0),
            "R2": float(r2_t0),
            "Reason": reason,
            "ExitBox": exit_box,
            "PnL": float(pnl)
        })

    trades_df = pd.DataFrame(trades)
    if trades_df.empty:
        return trades_df, pd.DataFrame()

    # PnL tracker (mark-to-market en continu)
    trades_df = trades_df.sort_values("Entry").reset_index(drop=True)
    start_all = trades_df["Entry"].min()
    end_all   = trades_df["Exit"].max()
    all_dates = y_all.loc[(y_all.index >= start_all) & (y_all.index <= end_all)].index
    pnl_tracker = pd.DataFrame(index=all_dates)

    for i, row in trades_df.iterrows():
        entry = row["Entry"]; exit_ = row["Exit"]
        side  = +1 if row["Side"] == "LONG_BOX" else -1
        entry_box = row["EntryBox"]

        ser = pd.Series(0.0, index=all_dates)  # 0 le jour d’entrée
        # MtM entre (entry; exit]
        in_window = (ser.index > entry) & (ser.index <= exit_)
        if in_window.any():
            box_slice = y_all.reindex(ser.index).loc[in_window]
            ser.loc[in_window] = -side * (box_slice - entry_box) * dv01_k
        # valeur figée après sortie
        after_exit = ser.index > exit_
        if after_exit.any():
            ser.loc[after_exit] = ser.loc[ser.index == exit_].iloc[0]

        pnl_tracker[f"Trade_{i+1}"] = ser

    pnl_tracker["CumPnL"] = pnl_tracker.sum(axis=1)

    # PnL réalisé cumulé (par ordre de sortie)
    trades_df = trades_df.sort_values("Exit").reset_index(drop=True)
    trades_df["RealizedCumPnL"] = trades_df["PnL"].cumsum()

    return trades_df, pnl_tracker


# =========================
# PLOTS — Résultats du backtest
# =========================
def plot_cum_pnl_realized(trades_df: pd.DataFrame, title="Realized Cumulative PnL (k€)"):
    """Trace le PnL réalisé cumulé (somme des PnL à la date de sortie de chaque trade)."""
    if trades_df.empty:
        print("Pas de trades générés."); return
    plt.figure(figsize=(12,5))
    plt.plot(trades_df["Exit"], trades_df["RealizedCumPnL"])
    plt.title(title); plt.xlabel("Exit date"); plt.ylabel("Cum PnL (k€)")
    plt.grid(True); plt.show()

def plot_portfolio_pnl(pnl_tracker: pd.DataFrame, title="Portfolio PnL (mark-to-market)"):
    """Trace le PnL cumulé mark-to-market (positions ouvertes + fermées figées)."""
    if pnl_tracker.empty:
        print("Pnl tracker vide."); return
    plt.figure(figsize=(12,5))
    plt.plot(pnl_tracker.index, pnl_tracker["CumPnL"])
    plt.title(title); plt.xlabel("Date"); plt.ylabel("Cum PnL (k€)")
    plt.grid(True); plt.show()


# =========================
# ==== EXEMPLES D’APPELS SÉPARÉS ====
# =========================

# Hypothèse: `data` existe (index Datetime trié, colonnes "Country Matu")

# 1) === ANALYSE NIVEAUX (fenêtre courte pour l’explo, ex: 63) ===
# series_lvl, rr_spread_lvl_63, rr_curve_lvl_63 = run_analysis_levels(data, window=63, do_plots=True)

# 2) === ANALYSE DAILY CHANGES (fenêtre courte pour l’explo, ex: 63) ===
# changes, rr_spread_chg_63, rr_curve_chg_63 = run_analysis_daily_changes(data, window=63, do_plots=True)

# 3) === BACKTEST À PARTIR DE LA ROLLING REGRESSION (fenêtre TRAIN = 126 obs) ===
#    -> on recalcule la rolling OLS sur NIVEAUX avec fenêtrage 126 (et sans plots),
#       puis on réutilise Alpha/Beta/R² + on applique un OBS_WINDOW de 21 obs
# series_bt, rr_spread_bt, rr_curve_bt = run_analysis_levels(data, window=TRAIN_WINDOW_DAYS, do_plots=False)

#    -> Choix du driver: "SPREAD" (ou "CURVE")
# rr_driver = rr_spread_bt  # ou rr_curve_bt si tu veux baser la strat sur la courbe
# trades_df, pnl_tracker = backtest_from_rr(
#     series_bt,
#     rr_driver,
#     driver=DRIVER_FOR_SIGNAL,       # "SPREAD" si rr_driver = rr_spread_bt ; "CURVE" si rr_driver = rr_curve_bt
#     obs_window_days=OBS_WINDOW_DAYS,  # 21 obs de cooldown
#     holding_days=HOLDING_DAYS,        # 21 obs max
#     resid_threshold=0.5,              # ex pour tester des entrées plus fréquentes
#     r2_entry_threshold=0.0,           # ex: sans filtre R² pour tester
#     tp_mult=TP_MULT,
#     sl_mult=SL_MULT,
#     dv01_k=DV01_K
# )
# print(trades_df.head())
# print(pnl_tracker.head())
# plot_cum_pnl_realized(trades_df, "Realized PnL — RR-based backtest (Levels)")
# plot_portfolio_pnl(pnl_tracker, "Portfolio MtM PnL — RR-based backtest (Levels)")

